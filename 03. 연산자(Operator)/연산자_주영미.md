노션 링크: https://www.notion.so/Chapter-3-operator-6650892fee954983b530446237ef4bc4?pvs=4

연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/d673c204-b000-42cd-bef7-9cc4b9293c32/Untitled.png)

피연산자의 개수로 단항 연산자, 이항 연산자, 삼항 연산자를 분류하는데, 삼항 연산자는 ‘?:’ 하나뿐이다.

### 연산자의 우선순위

1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/56a1b3cc-5a9c-4377-bb85-966d4e1f1b51/Untitled.png)

### 산술 변환(usual arithmetic conversion)

연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 ‘산술 변환’ 또는 ‘일반 산술 변환’이라 한다.

1. 두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치)
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환한다.
3. 모든 연산에서 산술 변환이 일어나지만, 쉬프트 연산자(<<, >>), 증감 연산자(++, —)는 예외이다.

# 단항 연산자

### 증감 연산자 ++ —

> 대부분의 연산자는 피연산자의 타입이나 값을 변경시키지 않는다. 오직 대입연산자와 증감연산자만 피연산자의 값을 변경한다. 증감연산자는 일반 산술 변환에 의한 자동 형변환이 발생하지 않으며, 연산결과의 타입은 피연산자의 타입과 같다.
>

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/85b327ee-90c1-4231-bd3a-35a673b9b7e4/Untitled.png)

![IMG_4996.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/11db76d2-dbc1-44c6-91d1-219eb64d341e/IMG_4996.heic)

### 부호 연산자 + -

부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용할 수 있다. 부호 연산자는 덧셈, 뺄셈연산자와 같은 기호를 쓰지만 다른 연산자이다. 기호는 같아도 피연산자의 개수가 달라서 구별이 가능하다.

# 산술 연산자

- 나누기 연산에서 두 피연산자가 모두 int 타입인 경우, 연산결과 역시 int 타입이다.
- 피연산자가 유한수가 아닌 경우의 연산결과

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/faebed9c-7ddd-45e7-9a7b-a07caacf01d5/Untitled.png)

- 문자 ‘2’를 숫자로 변경하려면 ‘2’ - ‘0’ = 50 - 48 = 2.
- 대문자와 소문자 간의 코드값 차이는 10진수로 32이다.
- char 과 int 형의 연산 결과는 int 형이므로, 연산 후 char 형으로 다시 형변환해야 한다!

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/7767cb71-0fe6-4681-ae6c-8d01d6e6efdc/Untitled.png)

- 변수가 들어가면 int 보다 작은 타입의 연산 시 int로 형변환되지만 리터럴의 연산은 형변환을 안 해도 된다.

    ```java
    char c1 = 'a';
    char c2 = c1 + 1; //컴파일 에러 발생!! 변수가 있어 컴파일이 연산을 수행해주지 못함
    char c3 = 'a' + 1; //컴파일 에러 없음. 컴파일이 덧셈 연산을 수행해줌. 
    ```

- 나눗셈 연산자의 성질을 이용하여 실수형 변수 pi의 값을 소수점 셋째 자리까지만 빼내는 방법
    - (int)(pi * 1000) / 1000f
- 반올림 하는 법
    - (int)(pi * 1000 + 0.5) / 1000.0
    - Math.round(pi * 1000) / 1000.0
- 나머지 연산에서 부호는 모두 무시하고 연산 결과에 왼쪽 피연산자의 부호를 붙이면 된다.

# 비교 연산자

- 대소비교 연산자(<, >, ≤, ≥)는 참조형에 사용할 수 없다.
- 등가비교 연산자(==, !=)는 모든 자료형에 사용할 수 있다. 참조형의 경우 객체의 주소값이 같은지, 같은 객체를 가리키고 있는지를 알 수 있다.
- float 타입의 값과 double 타입의 값을 비교하는 방법
    - double 타입의 값을 float 타입의 값으로 형변환한 다음에 비교한다. 또한, 어느 정도의 오차는 무시하고 두 타입의 값을 앞에서 몇 자리만 잘라서 비교할 수도 있다.
- 문자열의 비교에는 equals()를 사용. 대소문자를 구분하고 싶지 않다면 equalsIgnoreCase()



# 논리 연산자

### 효율적인 연산(short circuit evaluation)

- OR연산의 경우, 두 피연산자 중 어느 한 쪽만 참이어도 결과가 참이므로 좌측 피연산자가 참이면, 우측 피연산자의 값은 평가하지 않는다.
- AND 연산의 경우 한 쪽만 거짓이면 결과가 거짓이기에 좌측 피연산자가 거짓이면 우측 피연산자는 평가하지 않는다.
- 그러므로 우선순위나 빈도가 높은 식을 왼쪽에 놓으면 더 효율적으로 처리된다.

# 비트 연산자 & | ^ ~ << >>

비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자로 실수는 허용하지 않는다.-

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/c9848791-793d-42d4-bbc5-a209a0c86148/Untitled.png)

- ‘|’는 주로 특정 비트의 값을 변경할 때, ‘&’은 주로 특정 비트의 값을 뽑아낼 때 사용한다.
- ‘^’는 같은 값으로 두고 연산을 수행하면 원래의 값으로 돌아오는 특징이 있어서 간단한 암호화에 사용한다.
- 비트전환연산자 ‘~’는 ‘1의 보수’연산자라고도 한다.
    - 양의 정수 p가 있을 때 p에 대한 음의 정수를 얻으려면 ‘~p+1’을 계산하면 된다
    - 음의 정수 n이 있을 때 n에 대한 양의 정수를 얻으려면 ‘~(n-1)’을 계산하면 된다
    - ‘~~p’는 변수 p에 비트 전환 연산자를 두 번 적용한 것인데, 원래의 값이 되지만 연산결과의 타입이 byte가 아니라 int다.

# 쉬프트 연산자 << >>

<<: 자리 이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워진다.

>>: MSB로 빈자리를 채우고 오른쪽에 자리 이동으로 저장범위를 벗어난 값들은 버려진다.

- 쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되어 int보다 작은 타입은 int타입으로 자동 변환되고 연산결과 역시 int 타입이 된다.
- 그러나 쉬프트 연산자는 다른 이항연산자들과 달리 피연산자의 타입을 일치시킬 필요가 없기 때문에 우측 피연산자에는 산술변환이 적용되지 않는다.

<aside>
💡 x << n은 x * 2^n의 결과와 같다.
x >> n은 x / 2^n의 결과와 같다.

</aside>

- 이동하려는 n의 값이 자료형의 bit 수 보다 크면, 자료형의 bit수로 나눈 나머지만큼만 이동한다.
- ex.) int 타입이 4 바이트인 경우, ‘
    - 8>>32’는 아무 일도 일어나지 않는다
    - ‘8>>34’는 34를 32로 나눈 나머지인 2만큼만 이동하는 ‘8>>2’를 수행한다.
- 당연히 n은 정수만 가능하며 음수인 경우, 부호없는 정수로 자동 변환된다.
- 쉬프트 연산자는 곱셈이나 나눗셈에 비해 속도가 더 빠르다.

# 그 외의 연산자

### 조건 연산자 ? :

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/be4cb80b-af00-47ec-89fb-db8c145c40cf/Untitled.png)

- 조건 연산자의 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항 연산자처럼 산술 변환이 발생한다.

  ![IMG_4997.heic](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b02651c-b1e4-4baa-87b9-77c7970989fe/28763ed5-3e4a-4136-b19c-4ede99cbd1bc/IMG_4997.heic)

    - 위의 식에서 조건 연산자의 피연산자 0과 0.5의 타입이 다르므로, 자동 형변환이 일어나서 double 타입으로 통일되고 연산결과 역시 double 타입이 된다.

### 대입 연산자 = op=

대입 연산자는 연산자들 중 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 수행된다.

진행 방향은 오른쪽에서 왼쪽이다.